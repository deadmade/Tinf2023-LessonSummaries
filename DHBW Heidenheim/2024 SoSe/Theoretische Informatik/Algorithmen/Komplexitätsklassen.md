| Klasse     | Art der Komplexität                                                        | Beispiel                                                                                                  |
| ---------- | -------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------- |
| O(1)       | Die Rechenzeit ist unabhängig von der Problemgröße.                        | Sequenz                                                                                                   |
| O(log n)   | Die Rechenzeit wächst logarithmisch (Basis 2) mit der Problemgröße.        | Häufig bei Zerlegung eines Problems in Teilprobleme und Berechnung eines Teilproblems (z.B. binäre Suche) |
| O(n)       | Die Rechenzeit wächst linear mit der Problemgröße.                         | Abarbeitung eines eindimensionalen Arrays über den Eingabedatenbereich (z.B. lineare Suche)               |
| O(n log n) | Die Rechenzeit wächst linear logarithmisch (Basis 2) mit der Problemgröße. | Häufig bei Zerlegung eines Problems in Teilprobleme und Berechnung aller Teilprobleme                     |
| O(n²)      | Die Rechenzeit wächst quadratisch mit der Problemgröße.                    | Einfache Sortieralgorithmen (z.B. Bubble Sort), Abarbeiten von 2-D Strukturen                             |
| O(n³)      | Die Rechenzeit wächst kubisch mit der Problemgröße.                        | Z.B. Matrixmultiplikation, Abarbeiten von 3-D Strukturen                                                  |
| O($2^n$)   | Die Rechenzeit wächst exponentiell mit der Problemgröße.                   | Typisch für kombinatorische Aufgaben (z.B. Türme von Hanoi)                                               |
| O(n!)      | Abarbeitung aller Permutationen.                                           | Weglängenbestimmung in Bäumen                                                                             |
