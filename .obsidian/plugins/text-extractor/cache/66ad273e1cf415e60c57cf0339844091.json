{"path":"DHBW Heidenheim/2025 WiSe/Technische Informatik II/Skript/3d ARM Befehle.pdf","text":"Studiengang Informatik RISC-Prozessoren am Beispiel ARM: Befehle S. Berninger DHBW Heidenheim 118.01.2024 Studiengang Informatik ARM 7 (ARMv3) S. Berninger DHBW Heidenheim 2 • Architektur: ARM v3 • Modelle 1991 – 1993 ARM700, ARM710, ARM710a, ARM7100, ARM7500, ARM7500FE • 12–40 MHz, 0,889 DMIPS/MHz • RISC, Load-Store-Architektur • modifizierte Harvard-Architektur (getrennte Busse zum L1 Daten- und Adress-Cache, aber gemeinsamer weiterer Speicher) • 3-stufige Pipeline, 16 UserMode-Register, Barrel-Shifter • Registerbreite: 32 Bit • http://bear.ces.cwru.edu/eecs_382/ARM7-TDMI-manual-pt2.pdf 18.01.2024 Studiengang Informatik ARM Cortex A9 (ARMv7) S. Berninger DHBW Heidenheim 3 • Architektur: ARM v7 • Modelle 2004-2011 ARM Cortex-A (A8, A9, A5, A15, A7, A12, A15) ARM Cortex-M (M3, M4, M7) ARM Cortex-R (R4, R5, R7, R8) • RISC, Load-Store-Architektur • modifizierte Harvard-Architektur (getrennte Busse zum L1 Daten- und Adress-Cache, aber gemeinsamer weiterer Speicher) • NEON Multimedia Befehlssatzerweiterung, SIMD-Befehle • 8-stufige Pipeline, 16 UserMode-Register, Barrel-Shifter • Registerbreite: 32 Bit • enthalten auf vielen SOCs • http://bear.ces.cwru.edu/eecs_382/ARM7-TDMI-manual-pt2.pdf 18.01.2024 Studiengang Informatik ARM Befehlssatz: Generelles Hauptfeatures des ARM-/ Thumb-Befehlssatzes: • Die meisten Befehle brauchen nur einen Takt • Load/ Store – Architektur • Datenverarbeitungsbefehle arbeiten nur mit Registern • ALU mit Shifter kombiniert für schnelle Bitmanipulation • Spezifische Speicher<->Register -Befehle mit mächtigem Index-Adressierungsmodes • flexible Mehrfachregister Load- & Store-Befehle • Befehlssatzerweiterung SVE2 durch Koprozessoren (für Graphik- (GPUs (Mali)) und KI- Datenverarbeitung (NPU)) S. Berninger DHBW Heidenheim 418.01.2024 Studiengang Informatik Befehlssätze/ Execution states: ARM vs. Thumb S. Berninger DHBW Heidenheim 5 Kriterium ARM Thumb Befehlsbreite 32 Bit 16 Bit Bedingte Befehlsausführung Fast immer bedingt Fast immer unbedingt Befehlsumfang Voller Befehlssatz Subset des ARM-Befehlssatzes UAL-Unterstützung Unterstützt vom Assembler Unterstützt vom Assembler Operandenzahl 3 Operanden 2 Operanden Speichermodell ARMv3 und danach: Standard: Little Indian, änderbar Weitere ARM-Befehlssätze: • Thumb-2 (16/32 mixed), Jazelle/ DBX for Java bytecode (8 Bit), NEON 64/128-SIMD, VFP vector floating point IS 18.01.2024 Studiengang Informatik Die ARM-Datenpfad- Architektur S. Berninger DHBW Heidenheim 618.01.2024 inkl. PC, IR, SP, ... Studiengang Informatik Die ARM - ALU S. Berninger DHBW Heidenheim 7 Inverter 18.01.2024 Studiengang Informatik Die ARM7 Pipeline für ALU-Befehle (Operanden: Register) S. Berninger DHBW Heidenheim 8 3-stufige Pipeline Latenz: 3 Zyklen Durchsatz: 1 Befehl je Zyklus 18.01.2024 Studiengang Informatik Die ARM7-Pipeline für Load/Store-Befehle (Register<->Speicher) (Hazard in von-Neumann-Architekturen) S. Berninger DHBW Heidenheim 918.01.2024 Studiengang Informatik ARM Registerstruktur S. Berninger DHBW Heidenheim 10 „Current“ ProgramStatusRegister „Saved“ ProgramStatusRegister Stack-Frame-Pointer FP Intra-ProcureCall-Register IP Argument/ result/ scratch Argument/ result/ scratch Argument/ scratch Argument/ scratch 18.01.2024 Big bang theory – fun with flags https://youtu.be/Xl12Sp1KiEk 18.01.2024 S. Berninger DHBW Heidenheim 11Studiengang Informatik Current Program Status Register (CPSR) S. Berninger DHBW Heidenheim 12 Condition Code Flags • N = Negatives ALU Ergebnis • Z = Alu Ergebnis ist Null (Zero) • C = Alu Ergebnis erzeugte Carry • V = Alu erzeugte Overflow • Q = Saturation (Sättigung, 1-stabil) Interrupt Disable Bits • I = 1, disables IRQ • F = 1, disables FIQ („fast“ Interrupts, maskierbar, aber höher prior) T-Bit • T = 0, Prozessor in Arm State • T = 1, Prozessor in Thumb State Mode Bits • Spezifizieren den Prozessor Mode (user, system, irq,…) 18.01.2024 Termin 3, Aufgabe1.s: ADD->ADDS, Breakpoint auf „MOV R0, R1,…“; R1 im Registersatz CPSR auf 0 setzen CPSR-Flags ansehen, ADDS-Befehl ausführen, Flags erneut ansehen Studiengang Informatik Statusflags bei arithmetischen und logischen Befehlen S. Berninger DHBW Heidenheim 13 • Die Flags des Statusregisters werden nur bei den Test- und Compare-Befehlen automatisch gesetzt. • Alle anderen Befehle müssen die Statusbits explizit setzen. Dazu ist ein -S an den Befehl anzuhängen (Pseudobefehl). • Beispiel: SUBS r0, r0, #1 ADDS r0, r0, #1 18.01.2024 Studiengang Informatik Bedingte Ausführung von Befehlen S. Berninger DHBW Heidenheim 14 • Jeder Befehl kann bedingt ausgeführt werden. Dazu wird die Bedingung (vorher gesetzte Werte des Statusregisters) als Ergänzung an den Befehl angehängt. • Beispiel: CMP r0, #5 @ if (r0 != 5) - setzt Statusregister oder: LDR r1, #5 SUBS r1, r0, r1 @ if (r0-r1 != 0) - befehlS setzt Statusregister ADDNE r1, r1, r0 @ { r1 = r1 + r0 -r2 SUBNE r1, r1, r2 @ } @ NE = Ergebnis not equal zero • Dies ist eine Besonderheit des ARM32, die viele Tests und Verzweigungen (Sprünge im Programmfluss = neuer Fetch-Zyklus) erspart 18.01.2024 Studiengang Informatik Bedingte Ausführung von Befehlen S. Berninger DHBW Heidenheim 1518.01.2024 (Letztes Ergebnis) Studiengang Informatik Grundsätzliches zu ARM Drei Haupt-Befehlstypen • Befehle zur Datenverarbeitung (z.B. Addition) • Ablaufsteuerung (z.B. Verzweigungen) • Befehle zur Adressierung (z.B. Speicherzugriffe) Regeln: • Alle Operanden sind 32 Bit (Register, Konstanten,…) • Das Ergebnis ist 32 Bit und wird in einem Register abgelegt • 3 (optionale) Operanden: 2 als Input, 1 Operand für das Ergebnis Beispiel: ADD R0, R1, R2 ; R0 := R1 + R2 S. Berninger DHBW Heidenheim 1618.01.2024 Studiengang InformatikS. Berninger DHBW Heidenheim 17 L=1: load (0: store) / Branch with Link I(DP)=1: Reg/ use barrel shifter A=1: accumulates last operand U=1: up, add offset to base (0: down) I(LS)=0: offset is immediate value W=1: write address into base (0: no write-back) P=1: pre, add offset before transfer (0: post) S=1: Set condition codes B=1: transfer byte quantity (0: word) Ablaufsteuerung, Sprungbefehle Speicher- adressierung (LOAD/ STORE) Arithmetische und logische Datenverarbeitung (nur Register) Befehlscodierung 18.01.2024 Studiengang InformatikS. Berninger DHBW Heidenheim 18 L=1: load (0: store) / Branch with Link I(DP)=1: use barrel shifter A=1: accumulates last operand U=1: up, add offset to base (0: down) I(LS)=0: offset is immediate value W=1: write address into base (0: no write-back) P=1: pre, add offset before transfer (0: post) S=1: Set condition codes B=1: transfer byte quantity (0: word) Ablaufsteuerung, Sprungbefehle Speicher- adressierung (LOAD/ STORE) Arithmetische und logische Datenverarbeitung (nur Register) Befehlscodierung 18.01.2024 (Reg) Studiengang Informatik ARM-Prozessor Drei Befehlstypen • Befehle zur Datenverarbeitung (z.B. Addition, Multiplikation) • Ablaufsteuerung (z.B. Verzweigungen) • Befehle zur Speicheradressierung (LOAD/ STORE) S. Berninger DHBW Heidenheim 1918.01.2024 Studiengang Informatik Arithmetische und logische Befehle S. Berninger DHBW Heidenheim 20 Binärcodierung der Datenverarbeitungsbefehle 18.01.2024 Studiengang Informatik Assembler-Format S. Berninger DHBW Heidenheim 21 Arithmethische und logische Befehle im Assembler-Darstellung haben eines der beiden folgenden Formate: <op>{<cond>}{S} Rd, Rn, #<32-Bit-Immidiate> @ destination, operand1, operand2 <op>{<cond>}{S} Rd, Rn, Rm {,<shift>} @ destination, operand1, operand2, opt. shift op2 Rd: Destination Rn: Operand 1 (befehlsabhängig) Rm: Operand 2 (optional) Beispiel: ADD r0, r1, r2 @ ADD ohne Setzen der Flags ADDGTS r0, r1, r2, LSR r3 @ ADD nur bei GT, mit Setzen der Flags (shift um low-Byte-Wert des r3) ADD r0, r1, #4 MOV r0, r1 @ logischer Befehl 18.01.2024 Studiengang Informatik --------------------------- S. Berninger DHBW Heidenheim 2218.01.2024 Studiengang Informatik Arithmetische und logische Befehle S. Berninger DHBW Heidenheim 23 CC = condition codes r1= #1 r2=#2 // vor jedem Befehl AND r0, r1, r2 // r0=0 , keine Flags EOR r0, r1, r2 // r0=3 , keine Flags ORR r0, r1, r2 // r0=3 , keine Flags BIC r0, r1, r2 // r0=1 , keine Flags ADD r0, r1, r2 // r0=3 , keine Flags ADC r0, r1, r2 // r0=4 bei CY=1 SUB r0, r1, r2 // r0=-1 , keine Flags SBC r0, r1, r2 // r0=-2 bei CY=0 RSB r0, r1, r2 // r0=1, keine Flags RSC r0, r1, r2 // r0=0 bei CY=0 TST r1, r2 // Flags wie ANDS, NZCV=0100 TEQ r1, r2 // Flags wie EORS, NZCV=0000 CMP r1, r2 // Flags wie SUBS, NZCV=1000 CMN r1, r2 // Flags wie ADDS, NZCV=0000 MOV r1, r2 // r1=2, keine Flags MVN r1, r2 // r1=0xFFFFFFFD 18.01.2024 Studiengang Informatik Benutzung des Barrel Shifters S. Berninger DHBW Heidenheim 24 Operand 2 ist ein Register, zusätzlich kann eine Shift-Operation angewandt werden. Shift-Werte können sein: • 5 Bit unsigned integer (0...31 Shifts) • Wert in einem anderen Register (niedrigstes Byte, extra Takt) Wird benutzt zur Multiplikation des Op2 mit Konstanten. Operand 2 ist ein Immediate Wert + Rotate Operation • 8-Bit-Zahl im Bereich zwischen 0 und 255 • Kann nach rechts rotiert werden um gerade Zahl (s. Folie 27) 18.01.2024 ADD r0, r1, r2, LSL r3 SUB r0, r1, r2, LSL #6 Studiengang Informatik Der Barrel Shifter (logical shift) LSL...: Pseudobefehle für MOV mit Shift S. Berninger DHBW Heidenheim 25 nur bei „LSLS“! nur bei „LSRS“! 18.01.2024 Studiengang Informatik Der Barrel Shifter (arithmetic shift) S. Berninger DHBW Heidenheim 26 nur bei „ASRS“! 18.01.2024 Studiengang Informatik Der Barrel Shifter (rotate) S. Berninger DHBW Heidenheim 27 ´nur bei „RORS“! nur bei „RRXS“! 18.01.2024 Studiengang Informatik Multiplikation mit einer Konstanten S. Berninger DHBW Heidenheim 28 • Multiplikationen mit Konstanten, die sich als 2x oder als 2x ± 1 darstellen lassen, können in einem Zyklus durchgeführt werden • Beispiel: Multiplikation von r1 mit 5 add r0, r1, r1, LSL #2 // r0=r1+r1*4 • Durch Zusammensetzen mehrerer Instruktionen können auch komplexere Multiplikationen durchgeführt werden • Beispiel: Multiplikation von r1 mit 10 add r0, r1, r1, LSL #2 // r0 = r1 + r1*4 mov r0, r0, LSL #1; // r0 = r0*2 • Beipiel Multiplikation von r3 mit 119 = 17 * 7 = (16 + 1) * (8 - 1) add r2, r3, r3, LSL #4 // r2 = r3 + r3 * 16 = r3*17 r2=r3*17 rsb r2, r2, r2, LSL #3 // r2 = r2 * 8 - r2 = r2*7 r2=r2*7 18.01.2024 Studiengang Informatik Operand 2 als Konstante (immediate value) S. Berninger DHBW Heidenheim 29 • Das Befehlsformat für Datenverarbeitungsbefehle reserviert 12 Bits für Operand 2 (8 Bit Konstante, 4 Bit optionale Rechtsrotation) • 12 Bit ergäben einen Wertebereich von max. 212 = 4096 • Genutzt: Wertebereich mit 8 Bits ( 0 – 255 ) als 32-Bit-Wert (führende Nullen) + Rotation (4 Bit * 2 (implizit): um 2,4,6,8,… Stellen, = *4, *16, *64…) • Diese 8 Bit-Werte (24 führende Nullen) können (rechts) rotiert werden um eine geraden Anzahl von Positionen (ROR mit 0, 2, 4,..30). • Das ergibt eine weitaus größere Abdeckung des Zahlenbereiches: 8 zusammenhängende Bits innerhalb des 32-Bit-Wertebereichs! • Je größer die Werte, desto größer die Lücken (ungenauere Werte) • Einige Konstanten müssen dennoch vom Speicher geladen werden oder müssen in einem Register konstruiert werden. 18.01.2024 Studiengang InformatikS. Berninger DHBW Heidenheim 30 Abbildbare immediate Werte (je größer die Werte, desto größer die wertmäßigen Lücken) 18.01.2024 Studiengang Informatik Operand 2 als Konstante (immediate value) S. Berninger DHBW Heidenheim 31 • Wertebereiche: 0 - 255 [0 – 0xff] @ Distanz: 0 256,260,264,..,1020 [0x100-0x3fc, step 4, 0x40-0xff ror 30] @ Distanz: 4 1024,1040,1056,..,4080 [0x400-0xff0, step 16, 0x40-0xff ror 28] @ Distanz: 16 4096,4160, 4224,..,16320 [0x1000-0x3fc0, step 64, 0x40-0xff ror 26] @ Distanz: 64 … • Beispiel MOV – Befehl: MOV r0, #0xFF000000 ; umgesetzt im Befehlcode als => MOV r0, (#0xFF ROR 2*22) • Beispiel MVN: erzeugt das bitweise Komplement (1er Komplement) MOV r0, #0xFFFFFFFF ; umgesetzt im Befehl als MVN r0, #0 • Falls die benötigten Konstanten nicht erzeugt werden können, erzeugt der Assembler eine Fehlermeldung! Uff! 18.01.2024 Studiengang Informatik Multiplikation (nur Register-Register!) S. Berninger DHBW Heidenheim 32 Assembler Format: MUL{<cond>}{S} Rd, Rm, Rs @ mul=000 MLA{<cond>}{S} Rd, Rm, Rs, Rn @ mul=001 <mul>{<cond>}{S} RdHi, RdLo, Rm, Rs mul: Rd Rn 4 Bit für 16 Registernummern Ergebnis wird auf 2 Register aufgeteilt (64 Bit) 18.01.2024 Studiengang Informatik Übung 1 – bitte im Chat antworten S. Berninger DHBW Heidenheim 33 1. Welche Befehle implementieren folgende Zuweisungen (ohne explizite Multiplikation): a) r0 = 16 b) r1 = r0 * 4 c) r0 = r1 / 16 ( r1: 2er-Komplement mit Vorzeichen) d) r1 = r2 * 7 2. Was machen folgende Befehle ? a) ADDS r0, r1, r1, LSL #2 b) RSB r2, r1, #0 3. Was ergibt folgende Befehlssequenz ? ADD r0, r1, r1, LSL #1 SUB r0, r0, r1, LSL #4 ADD r0, r0, r1, LSL #7 18.01.2024 Studiengang Informatik Übung 2 r0 = 0xAABBCCDD • EOR r1, r0, r0, ror #16 • BIC r1, r1, #0xFF0000 • MOV r0, r0, ror #8 • EOR r0, r0, r1, lsr #8 r0 = ? S. Berninger DHBW Heidenheim 3518.01.2024 Studiengang Informatik Fragen zu den DV-Befehlen? S. Berninger DHBW Heidenheim 3718.01.2024 Studiengang Informatik Grundsätzliches zu ARM Drei Befehlstypen • Befehle zur Datenverarbeitung (z.B. Addition) • Ablaufsteuerung (z.B. Verzweigungen) • Befehle zur zur Speicheradressierung (LOAD/ STORE) S. Berninger DHBW Heidenheim 3818.01.2024 Studiengang Informatik Befehle zur Ablaufsteuerung Sprungbefehle (Branch): Ausführung wird dauerhaft an einer anderen Adresse fortgesetzt. Branch-and-Link-Befehle (entspricht Call): eine Rücksprungadresse wird gespeichert, so dass an die ursprüngliche Programmsequenz zurückgesprungen werden kann. Supervisor-Calls: Wechsel in den geschützten Systemcode, z.B. für Zugriffe auf Register von Peripherie Link-Register: bekommt bei Calls die Returnadresse , um deren aufwändiges Push und Pop in den Speicher zu vermeiden. Achtung: bei verschachtelten Aufrufen vor Call (BL) explizit auf den Stack sichern, und nach Rückkehr wieder herstellen! S. Berninger DHBW Heidenheim 3918.01.2024 Studiengang Informatik Assembler-Format Assembler-Formate der Sprungbefehle: B{L}{<cond>} <Zieladresse> Branch w/o Linkr. (mit oder ohne Füllen des Link registers aus dem PC) B<cond> = (un-)bedingter Sprung (JMP oder JNE oder JGE oder … BL<cond> = (un-)bedingter Call B{L}X{<cond>} Rm Branch with optional Exchange w/0 Linkregister = Jump oder Call mit erlaubtem Wechsel des Modes (ARM<->Thumb) BLX <Zieladresse> Branch with Exchange and Linkregister = Call mit Modewechsel in Thumb, akt. Mode wird ins LSB des LR gerettet (unterste 2 Bit sind 0, wenn aligned, LSB ist immer 0, da 16-Bit-Adressen immer gerade sind) BLX nur verfügbar in den T-Varianten ab ARM v5! S. Berninger DHBW Heidenheim 4018.01.2024 Studiengang Informatik Befehle zur Ablaufsteuerung S. Berninger DHBW Heidenheim 41 L: 1= Branch with Link, 0= Branch Binärcodierung der Ablaufsteuerungsbefehle Codierung für Branch: B, BL Zieladresse Codierung für Branch mit optionalem Exchange: BX Rn (LSB bestimmt Exchange) BLX Rn | Zieladresse 18.01.2024 Studiengang Informatik Sprungbefehle (Branch) • Sprungbefehle dienen dazu, den Kontrollfluss von Programmen zu verändern. • In der Kombination mit Vergleichsbefehlen können mit Ihnen alle wichtigen Kontrollflussanweisungen wie „if.. else“, „while“, „for“ oder „switch“ realisiert werden. • Das Ziel einer Sprung-/Callanweisung bei B/ BL ist immer eine Marke (Label), der Assembler erzeugt die Sprungadresse (PC-relativ, in 26 (24+2) Bit, niedrigste beide Bit nicht codiert, da immer =0: +- 32 MB relativ zum PC). • Beispiel: S. Berninger DHBW Heidenheim 4218.01.2024 Studiengang Informatik Sprungbefehle (auch bedingt) S. Berninger DHBW Heidenheim 4318.01.2024 Studiengang Informatik Unterprogramme (Branch-with-Link) S. Berninger DHBW Heidenheim 44 • Der Befehl BL (branch-with-link) führt einen Sprung aus und speichert die Rücksprungadresse im Link-Register r14 (LR) = Call. • Weitere Subroutinen müssen r14 (LR) vor dem Call im Speicher sichern, z.B. auf dem Stack, und nach erfolgter Rückkehr wieder herstellen. Arbeitsregister (>r3) sollten ebenfalls gesichert werden, wenn das Unterprogramm diese benötigt. • Beispiel: (besser: BX LR, da Thumb PC im MOV-Befehl nicht zulässt) PUSH LR @ wenn man selbst ein UP ist und zurückkehren möchte POP LR 18.01.2024 Studiengang Informatik (A)APCS Konvention zur Parameterübergabe S. Berninger DHBW Heidenheim 45 • ARM (Architecture) Procedure Call Standard • Die Parameter 1-4 werden beim Unterprogrammaufruf in den Registern r0-r3 übergeben (Zeit und Stackplatz sparen). • Der Rückgabewert von Funktionen steht im Register r0 oder r0/r1. • Die Register r0-r3 und das Register ip sind Scratch Register und deren Inhalte dürfen im Unterprogramm zerstört werden. • Die Informationen in r4-r10, fp, sp müssen erhalten bleiben. • der Inhalt von lr wird zur Rückkehr ins aufrufende Programm benötigt – nicht zerstören! 18.01.2024 Studiengang Informatik Sprungbefehle mit Modewechsel S. Berninger DHBW Heidenheim 46 • BX Rn Branch and Exchange Als Argument erhält der Befehl eine Registeradresse. Der Inhalt der Registeradresse wird in den Programmcounter (r15) kopiert (niederwertigstes Bit ist sowohl bei ARM als auch Thumb-Mode=0, da mindestens 16-Bit aligned – dieses Bit wird benutzt zum Speichern des T-Mode-Bits). Ist die Zieladresse also ungerade, erfolgt ein Wechsel in den Thumbmode, ist die Zieladresse gerade, wird in den ARM Mode gewechselt. Der Befehl BX LR ist der Standardbefehl, um Unterprogramme zu verlassen, bei denen die Rücksprungadresse noch im Linkregister steht (Return). • BLX Label Branch and Link with Exchange Der Befehl BLX Label wird ab ARM v5 genutzt in Programmen mit gemischtem 32-Bit/Thumb Code (Call). • BLX Rn Branch and Link with Exchange Dieser Befehl führt ebenfalls (optional) einen Modewechsel durch und speichert die nächste Adresse nach diesem Befehl im Linkregister (Call) (ab ARM v5). 18.01.2024 Studiengang Informatik Unterprogrammaufruf mit Modewechsel S. Berninger DHBW Heidenheim 47 Beispiel: 18.01.2024 Studiengang Informatik Befehle zur Ablaufsteuerung S. Berninger DHBW Heidenheim 48 • Der Befehl MOV PC, Rd ist seit Einführung des Thumb Befehlssatzes, der einen direkten Zugriff auf den PC in diesem Befehl nicht mehr zuließ, nicht mehr empfohlen. Stattdessen wurden die Befehle BX und BLX eingeführt. • Alle Sprungbefehle (inkl. Calls) können bedingt ausgeführt werden 18.01.2024 Studiengang Informatik ARM-Befehle Fortsetzung… S. Berninger DHBW Heidenheim 4918.01.2024","libVersion":"0.3.2","langs":""}