{"path":"DHBW Heidenheim/2025 WiSe/Technische Informatik II/Skript/2c MU1 Skript.pdf","text":"Studiengang Informatik Grundlagen von Prozessoren: Review MU0-Rechner S. Berninger DHBW Heidenheim 1Studiengang Informatik Ein genauer Blick Add_instr: 0010|0000.0001|1100 ADD Table ; ACC+=<0x1C> 0001|0000. 0001|0110 STO Total ; <Total>=ACC 0000|0000. 0000|0010 LDA Add_Instr ; ACC=<Add_Instr> 0010|0000. 0001|1000 ADD Two ; ACC+=<0x26> 0001|0000. 0000|0010 STO Add_Instr; <Add_Instr>=ACC S. Berninger DHBW Heidenheim 2 [Add_Instruction]+=2 Studiengang Informatik Was sollte ein Rechner können – und was kann der MU0? Rechnen • Addition, Subtraktion, Multiplikation, floating point, etc Datenbewegung (kopieren) Strukturierte Lösung eines Problems • Abfolge von Rechenoperationen • Verwendung von Daten, Indirekte Adressierung, Pointer • Schleifen, Sprünge • Unterprogramme (Strukturen) Spezielle Befehle (z.B. Interrupts zur Anbindung der Peripherie) Effizienz • Optimieren der Datenzugriffe (schneller) • mehr Daten • spezielle Algorithmen, z.B. Graphik, Audio-Codecs, etc. Energieeffizienz S. Berninger DHBW Heidenheim 3Studiengang Informatik Nächste Generation: MU1 Rechnen • Addition, Subtraktion, Multiplikation, floating point, etc Datenbewegung (kopieren) Strukturierte Lösung eines Problems • Abfolge von Rechenoperationen • Verwendung von Daten, Indirekte Adressierung, Pointer • Schleifen, Sprünge • Unterprogramme (Strukturen) Spezielle Befehle (z.B. Interrupts zur Anbindung der Peripherie) Effizienz • Optimieren der Datenzugriffe (schneller) • mehr Daten • spezielle Algorithmen, z.B. Graphik, Audio-Codecs, etc. Energieeffizienz S. Berninger DHBW Heidenheim 4Studiengang Informatik Grundlagen von Prozessoren: Die Rechnergeneration MU1 S. Berninger DHBW Heidenheim 5Studiengang Informatik ALU im Detail S. Berninger DHBW Heidenheim 6 FA: Funktion (0, 1=A) (also eigentlich F0A) 1 0 *1 *2 C: Funktionsergebnis C F1: Funktion (0/ 1) FC: Funktion (0=F1, 1=Carry-Flag) FIB: Funktion (0: B, *2: Inverter, B) FIA: Funktion (0: A, *1: Inverter, A) FS: Funktionsergebnis Statusregister FB: Funktion (0, 1=B) (also eigentlich F0B) FA FB FIA FIB FC F1 FS Erg C Studiengang Informatik ALU im Detail S. Berninger DHBW Heidenheim 7 • A+B ist der Ausgang des Addierers. • A-B wird gebildet als A+B+1. • B wird implementiert, indem der Eingang A fest auf 0 gesetzt wird • A+1 wird implementiert, indem der Eingang B fest auf 0 gesetzt und der F1-Eingang auf 1 gesetzt wird • Alle Funktionen dieser einfachen ALU können also durch einen Addierer mit Carry-Eingang gebildet werden, dessen Eingang A auf Null gesetzt und dessen Eingang B invertiert werden kann. • Übung: Wie kann man mit dieser ALU A-1 berechnen? Studiengang Informatik Die Grundfunktionen der ALU S. Berninger DHBW Heidenheim 8 FS wird gesetzt, wenn die Operation es erfordert und erlaubt (Flags werden geändert) (Funktion) ? 1 0 *1 *2 Studiengang Informatik Die Grundfunktionen der ALU S. Berninger DHBW Heidenheim 10 (Funktion) ? 1 0 *1 *2 Studiengang Informatik Die Grundfunktionen der ALU S. Berninger DHBW Heidenheim 12 (Funktion) 1 0 *2 Studiengang Informatik Der MU1-Datenpfad S. Berninger DHBW Heidenheim 13 Das erweitere MU0 Modell besitzt • einen Stackpointer SP und • Register Din und Dout. Laufzeiten sind kürzer pro Takt Durch die zusätzlichen Register Din und Dout braucht unser Modell jetzt zwar mehr Taktzyklen, aber diese können schneller durchlaufen werden (teilweise kein Speicherzugriff) Vorteil: versetzte Parallelität, Laden und Speichern nur über Register, Operationen (ALU) greifen nie direkt auf Speicher zu Studiengang Informatik MU1-Datenpfad S. Berninger DHBW Heidenheim 14Studiengang Informatik MU1-Datenpfad S. Berninger DHBW Heidenheim 15 LDA S Takt 1 Takt 3 Studiengang Informatik MU1-Datenpfad S. Berninger DHBW Heidenheim 16 LDA S Takt 2 Studiengang Informatik MU1-Datenpfad S. Berninger DHBW Heidenheim 17 LDA S Takt 3 B Studiengang Informatik MU1-Elemente ohne Speicher und Steuerwerk S. Berninger DHBW Heidenheim 18 Akkumulator: ie -> Lesen, oe -> Schreiben Program Counter: ie ->Lesen, oe -> Schreiben Instruction Register: ie -> Lesen, oe → Schreiben ALU: Funktionsauswahl über ALUfs (function select) Adressbusmultiplexer A: 0 -> A-Bus, 1 -> B-Bus Stackpointer Register: ie -> Lesen, oe → Schreiben DataIn Register: ie -> Lesen, oe → Schreiben DataOut Register: ie -> Lesen, oe → Schreiben Studiengang Informatik Der Micro-Program-Counter Step • Step ist ein Speicher in der Steuereinheit (Timing/Control Unit) unseres Prozessors. • Die meisten Befehle unseres Prozessors werden nicht in einem Takt ausgeführt, sondern erfordern mehrere Takte. Der Microprogram Counter Step gibt der Steuerlogik die Information, welche Aktionen (Fetch/ Execute) jeweils auszuführen sind. Dazu wird Step (Takt) als Eingangsinformation für jeden Schritt verarbeitet. • Zu jedem Schritt steht in der Steuerungstabelle, welcher Wert Step in diesem Schritt zugewiesen wird, das heißt: welches der nächste Schritt ist. S. Berninger DHBW Heidenheim 19Studiengang Informatik Der Micro Program Counter Step • Im ersten Schritt eines Befehls (Step ist vorher Null), erfolgt immer der Fetch, das heißt das Lesen des Befehls in das Instruction Register. Der Opcode des Befehls wird dabei ignoriert. • Im letzten Schritt eines Befehls wird Step wieder auf Null gesetzt, so dass danach ein Fetch ausgeführt wird. • In den meisten Fällen wird Step in einem Schritt um Eins erhöht. S. Berninger DHBW Heidenheim 20Studiengang Informatik Befehlsablauf MU1 nach Reset S. Berninger DHBW Heidenheim 21 ja N Mikroschritte PC initialisiert Studiengang Informatik MU1-Befehl S. Berninger DHBW Heidenheim 22Studiengang Informatik Der Fetch Zyklus im MU1 (Step 0->1, 1 Takt) S. Berninger DHBW Heidenheim 23 • Der Program Counter (PC) wird auf den Adressbus geschaltet und gleichzeitig an den Eingang A der ALU. • An der ALU ist der Befehl A+1 ausgewählt, S ist 0. A+1 • In der zweiten Hälfte des Takts wird vom Speicher die nächste Instruktion gelesen und in IR gespeichert. Studiengang Informatik LDA: Das Laden des Akkumulators mit dem Inhalt einer absoluten Adresse S. Berninger DHBW Heidenheim 24 Der Adressteil der Instruktion wird aus dem Instruction Register auf den Adressbus gelegt und der Speicherinhalt nach Din geschrieben, und dann über die ALU in den ACC. 1 0 1 Studiengang Informatik STO s: Das Speichern des Akkumulatorinhalts auf eine absolute Adresse S. Berninger DHBW Heidenheim 25 Der Akkuinhalt wird nach Dout gebracht. Der Adressteil der Instruktion wird aus dem Instruction Register auf den Adressbus gelegt und der Inhalt von Dout in den Speicher geschrieben. 0 Studiengang Informatik Zustandsbeschreibung des Ladebefehls S. Berninger DHBW Heidenheim 26 • Jeder Befehl beginnt mit einem Fetch-Zyklus. • Nach dem Fetch-Zyklus entscheidet der Opcode im Instruction Register und die Schrittnummer, welchen Zustand unser Automat als nächstes annimmt. • Die Schrittnummer (Step) ist unser Programmcounter im Microcode und beschreibt die Abfolge der Befehle im Microcode. • Zu jedem Schritt gehört eine eindeutige Funktion, die sich wiederum in die Timing-Control-Logik umsetzen läßt. Studiengang Informatik Adressierungsarten Unmittelbare Adressierung (immediate) • Der Befehl enthält eine Konstante • Beispiel: ADD #1 Direkte Adressierung (direct, absolute) • Der Befehl enhält eine Adresse im Speicher, an der sich der Operand befindet. • Beispiel: LDA S S gibt ein Adresse im Speicher an Indirekte Adressierung (indirect) • Der Befehl enthält eine Adresse, an der sich die effektive Adresse des Inhalts befindet. • Beispiel: LDR S S gibt eine indirekte Adresse an S. Berninger DHBW Heidenheim 27Studiengang Informatik Direkte Adressierung S. Berninger DHBW Heidenheim 28 • Bei der direkten Adresse enthält der Befehl LDA bzw. STA direkt die Speicheradresse, an die gespeichert oder von der gelesen werden soll. • Die Adresse ist somit im Programm festgeschrieben und kann zur Laufzeit nicht mehr geändert werden. • (Nur noch mit selbstmodifizierendem Code…) DOUT DIN STO Studiengang Informatik Indirekte Adressierung S. Berninger DHBW Heidenheim 29 • Die Adresse, an die gespeichert oder von der gelesen werden soll, steht nicht mehr direkt im Befehl. Im Befehl steht nur noch die Speicherstelle, an der sich ein Zeiger auf die Adresse befindet. • Die effektive Adresse kann somit berechnet werden. Mit diesem Befehl ist es möglich, über Arrays zu iterieren, ohne dass dazu selbstmodifiziernder Code nötig ist. DOUT DIN Studiengang Informatik Der Stack S. Berninger DHBW Heidenheim 30Studiengang Informatik Der Stack S. Berninger DHBW Heidenheim 31 111: STACK_BOTTOM: -Adr.- - Werte - 100: DEFW 11 SP PUSH A <A> 100 101 102 103 104 105 106 107 108 109 110 111 SP POP A 0 1 A 2 0 A 1 2 z.B. 0x42 DIN DOUT Studiengang Informatik Der Stack S. Berninger DHBW Heidenheim 32 • Der Stack stellt einen dynamischen Speicher dar, auf dem Daten zwischengespeichert werden können. • Die Grundoperationen eines Stacks sind die Operationen Push und Pop. • Push erniedrigt den Stackpointer und schiebt dann einen Wert in das Speicherwort, auf das der Stackpointer gerade zeigt („legt ab“) und • Pop liest ein Speicherwort von der Adresse auf die der Stackpointer zeigt („nimmt runter“) und erhöht den Stackpointer. • Der Stackpointer zeigt initial auf STACK_BOTTOM (leeres Gabbionengefäss) • Das unterste Wort eines Stacks bleibt immer ungenutzt und kann deshalb für die „Unterlauf“-Überwachung benutzt werden. 1100: STACK_BOTTOM -Adr.- - Werte - 1000: DEFW 100 1050: Studiengang Informatik Speicheransicht S. Berninger DHBW Heidenheim 33Studiengang Informatik Der Stack im Speicher S. Berninger DHBW Heidenheim 34 • Der Stackpointer wird am Anfang auf eine Adresse am Ende des Speicherbereichs gesetzt und wächst dann langsam „nach oben“ - zu den niederen Adressen. • Die Programme werden meistens in dem unteren Speicherbereich platziert und der Programmcounter beim Start auf die Adresse 0 gesetzt (s. MU0-Programm). • An den Programmbereich schließt sich als Nächstes der Datenbereich an. • Zwischen Daten und Stack findet man meist einen Heapbereich, eine andere Form der dynamischen Speicherverwaltung. DIN/OUT Studiengang Informatik Achtung! Die Speicheraufteilung kann auch kopfüber – mit der Adresse 0 unten - dargestellt werden! Achten Sie deshalb bei Darstellungen des Stacks oder der Speicheraufteilung immer darauf, in welche Richtung die Adressen steigen – und markieren Sie auch selbst in eigenen Darstellungen mit der 0 immer den Verlauf! S. Berninger DHBW Heidenheim 35Studiengang Informatik Unterprogramme S. Berninger DHBW Heidenheim 36 • Unterprogramme sind ein wichtiges Strukturierungsmittel für die Programmierung. • Unterprogramme werden mit einem Sprungbefehl (call, bl) angesprungen und die Adresse nach dem Sprungbefehl wird gespeichert. Nach dem Verlassen des Unterprogramms wird die Programmausführung an der gespeicherten Stelle fortgesetzt. • Der Rücksprung erfolgt, indem die gespeicherte Adresse wieder in den ProgramCounter übertragen wird. Studiengang Informatik Unterprogramm-Aufrufe (Freeze) S. Berninger DHBW Heidenheim 37 return Studiengang Informatik Unterprogramm-Aufrufe S. Berninger DHBW Heidenheim 38 • Unterprogrammaufrufe nutzen häufig (nicht bei jedem Prozessor) den Stack zur Speicherung der Rücksprungadresse. • Beim Call-Befehl wird die Adresse des nächsten nach der Rückkehr auszuführenden Befehls auf dem Stack gespeichert und die Sprungadresse aus dem Instruction register in den PC geladen. • Beim Return wird die Rücksprungadresse vom Stack geholt, in den PC geschrieben und in einem fetch- Zyklus die neue Instruktion geladen. 0 1 2 3 0 1 2 3 fetch return Studiengang Informatik Der Erweiterte MU1 Befehlssatz (16 Befehle) S. Berninger DHBW Heidenheim 39 Load <S> Store <S> Add <S> Sub <S> Jump Jump Grt./Equ. Jump Not Equ. Stop Call Return Push Pop Load indiRect Store indiRect Move PC Move SP Studiengang Informatik Der Reset • Jeder Prozessor hat einen Reset Eingang. Normalerweise ist dieser als /Reset also als „not Reset“ ausgeführt, so dass bei Anlegen einer 0 ein Reset ausgeführt wird. • Liegt am /Reset Eingang eine 0 an, so wird der Prozessor auf einen Grundzustand zurückgesetzt: Program Counter und Stackpointer werden auf 0 gestellt und der Microprogramcounter „Step“ wird ebenfalls auf 0 gesetzt. S. Berninger DHBW Heidenheim 40Studiengang Informatik Der Reset: Datenpfad + Steuercodes S. Berninger DHBW Heidenheim 41 • Die ALU wird auf die Funktion Null gesetzt und PC und SP mit diesem Wert geladen. • Der Counter Step in der Steuereinheit wird auf 0 gesetzt, so dass im nächsten Schritt ohne Reset ein Fetch von der Adresse 0 ausgeführt wird.0 Studiengang Informatik Steuertabelle (Reset) S. Berninger DHBW Heidenheim 42 / Studiengang Informatik Beschreibung der Microcodenotation durch einfache Sprache (I) S. Berninger DHBW Heidenheim 43 X = Y Der Inhalt des Registers Y wird nach X verschoben. X = Y op Z Der Inhalt von Y (A-Bus der ALU) wird mit Z (B-Bus der ALU) verrechnet und nach X transportiert. X = [Y] Y wird als Adressinformation genommen. Der Inhalt der Speicherstelle Y wird nach X transportiert. [X] = Y X wird als Adressinformation genommen und Y wird in diese Adresse geschrieben. Studiengang Informatik Beschreibung des Microcodes durch einfache Sprache (II) S. Berninger DHBW Heidenheim 44 ACC = Din • Der Inhalt von Din wird nach ACC transportiert, ACC und Din sind Registernamen. • Im Register Din muss oe (Output enable) gesetzt sein, im Register A muss ie (Input enable) gesetzt sein. • Da der Transport über die ALU erfolgt, muss ALUfunctionSelect B sein. • Da der Speicher nicht angesprochen wird (keine [] enthalten), ist MEMrq 0 und RnW X (beliebig). Din = [SP] • Der Inhalt von SP wird als Adressinformation benutzt. • Dazu muss der Adressmultiplexer auf 0 stehen. • Im Register SP muss oe (Output enable) gesetzt sein im Register Din muss ie (Input enable) gesetzt sein. • Da der Speicher angesprochen wird, muss MEMrq 1 sein, und da Din lesen möchte, muss RnW auch 1 sein. • Da die ALU nicht benutzt wird, kann ALUfunctionSelect auf X gesetzt werden. Studiengang Informatik Beschreibung des Microcodes durch einfache Sprache (III) S. Berninger DHBW Heidenheim 45 PC = PC + 1 • ALUfunctionSelect muss A+1 sein. • Der Programmcounter wird auf den A-Bus gelegt und in der zweiten Hälfte des Taktes wird das Ergebnis der Berechnung wieder in den Programcounter zurückgeschrieben. • oe und ie von PC müssen beide 1 sein. Din = [SP], SP = SP+1 • Beide Operationen können in einem Takt durchgeführt werden, da die Adressierung des Speichers in der ersten Takthälfte erfolgt. Das Lesen durch Din erfolgt in der zweiten Takthälfte. Studiengang Informatik Regeln für MU1 S. Berninger DHBW Heidenheim 46 [X] = Dout • Wird ein Datenwert in den Speicher geschrieben, muss die rechte Seite des Befehls Dout sein. • MEMrq = 1 und RnW = 0 • Der zu schreibende Wert muss vorher nach Dout gebracht werden. X = [Y] • Wird vom Speicher gelesen, muss die linke Seite (X) IR oder Din sein. • MEMrq = 1 und RnW = 1 Keine Adresse Wird in einem Befehl keine Adresse benutzt (keine [] , z.B. ACC=ACC+1), so ist MEMrq = 0 und RnW = 1 Nur ein Register darf jeweils auf einen Bus schreiben (A- oder B- Bus), aber alle dürfen mitlesen. Studiengang Informatik MU1-Befehl S. Berninger DHBW Heidenheim 47Studiengang Informatik Die Addition bei MU1 (nach Fetch) S. Berninger DHBW Heidenheim 48 Das Instruction Register wird zur Adressierung benutzt und der Wert nach Din gebracht Din = [IR]. Der Inhalt des Akkummulators wird auf den A-Bus gelegt und der Inhalt von Din auf den B-Bus. ALUfunction ist A+B,S (Summe und Statusflags) Studiengang Informatik Die Operation PUSH ACC: Der Akkumulator wird auf den Stack geschoben S. Berninger DHBW Heidenheim 49 Die Operation Push benötigt drei Schritte: SP = SP -1 Dout = Acc [SP] = Dout Im letzten Schritt wird der Micro Program Counter Step auf Null gesetzt, so dass sich ein Fetch-Zyklus anschließt. Studiengang Informatik Der MU1 Zustandsautomat (hier für lda, add und push) S. Berninger DHBW Heidenheim 50 • Nach dem Fetch des Opcodes wird jeweils der durch den Opcode vorgegebene Zustand angesprungen. • Durch die Step-Variable (Program Counter im Microcode) wird eine Schleife durchlaufen, die wieder bei Schritt 0 im Fetch-Zyklus endet. (Step) Studiengang Informatik Bedingte Sprünge S. Berninger DHBW Heidenheim 51 • Der bedingte Sprung JGE (Jump on Greater or Equal zero): In Abhängigkeit des Negative-Flags im Statusregister (entspricht Bit 15 des Akkumlators, ACC >= 0 oder ACC < 0) wird ein unterschiedlicher Zustand angesprungen: • Ist N = 0 (ACC >= 0) dann wird die Operation PC = IR ausgeführt. • Ist N = 1 (ACC < 0) so wird keine Operation ausgeführt (NOP). • Der bedingte Sprung JNE (jump on not equal) ist strukturell gleich, nur ist hier die Zusatzbedingung, dass der Accumulator Null (Zero- Flag = 1) ist. (Step) Studiengang Informatik MU1 Steuer-Logik für bedingte Sprünge S. Berninger DHBW Heidenheim 52 • Beide Befehle (s.u.) weisen jeweils 2 Zustände auf, die sich nur durch die Statusbits des Akkumulators (Inputs) unterscheiden. • Beide Zustände haben die Schrittnummer 1 und als Folgeschritt die Schrittnummer 0. • Die Funktion NOP ist dadurch gekennzeichnet, dass kein Registerinhalt verändert wird: • Alle Register haben oe und ie auf 0 • und der Speicher wird nicht angesprochen: MEMrq = 0 Studiengang Informatik Der Stop-Befehl S. Berninger DHBW Heidenheim 53 • Der Stop-Befehl hat als Folgezustand den Zustand Stop. • Es wird kein Fetch-Zyklus mehr ausgeführt, so dass die Zustandsmaschine in dieser Stellung angehalten wird. Studiengang Informatik Reset S. Berninger DHBW Heidenheim 54 • Ist das Reset-Signal angelegt, geht unsere Zustandsmaschine immer in den Zustand Reset • Im Reset Zustand: • werden Program Counter und SteckPointer auf Null gesetzt: PC = 0, SP=0 • und die Zustandsvariable Step (der Microprogram Counter) erhält ebenfalls den Wert 0 • Dadurch wird nach Beendigung des Reset Signals mit dem Zustand fetch fortgefahren und der Befehl von der Adresse 0 (PC) geholt Studiengang Informatik _________________________________________________________________________________________ S. Berninger DHBW Heidenheim 55","libVersion":"0.3.2","langs":""}