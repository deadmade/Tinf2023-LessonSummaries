{"path":"DHBW Heidenheim/2024 SoSe/Programmierung/UnterrichtsMaterial/C#_3_2_Methoden.pdf","text":"5. Klassen und Objekte S. Berninger DHBW Heidenheim Studiengang Informatik 1 Vorteile von OOP S. Berninger DHBW Heidenheim Studiengang Informatik 2 Basisklasse abgeleitete KlasseSpezialisierung über zusätzliche FelderGeneralisierung über Gemeinsamkeiten CVehicle • seats CTrucks • seats: 2 • payLoad: 2 CMoped • seats: 1 • helmets: 1 Membervariablen - Felder S. Berninger DHBW Heidenheim Studiengang Informatik 3 Automatische Initialisierung S. Berninger DHBW Heidenheim Studiengang Informatik 4 Lokale Variable dürfen vor einer Initialisierung/ Wertzuweisung nicht verwendet (gelesen) werden (Compilerfehler)! Instanzvariablen (eines Objekts) erhalten automatisch Voreinstellungswerte: (inkl. string) ... Zugriff in klasseneigenen und fremden Methoden S. Berninger DHBW Heidenheim Studiengang Informatik 5 Innerhalb der Instanzmethoden einer Klasse: Instanzvariablen des aktuellen (die Methode ausführenden) Objekts können direkt über ihren Namen angesprochen werden (siehe price, size). Gelegentlich kann es sinnvoll oder erforderlich sein, einem Instanzvariablennamen über das Schlüsselwort this eine Referenz auf das handelnde Objekt voranzustellen (z.B. bei gleichnamigen lokalen Variablen), wobei das Schlüsselwort und der Variablenname durch den Punktoperator zu trennen sind. private int seats; CTruck (int seats , /* ... */) { this.seats = seats; } Zugriff auf Methoden eines anderen Objekts: über . – Operator: if (truck.Seats < 2) ... // =0 // new CTruck (4, ... // this.seats=4; Memberfunktionen - Methoden S. Berninger DHBW Heidenheim Studiengang Informatik 6 Methoden In den Methoden eines Programms werden • vordefinierte (z. B. der FCL-Standardbibliothek entstammende) oder • selbst erstellte Klassen und Objekte zur Erledigung von Aufgaben verwendet. Ein Programm besteht aus Klassen, die als Baupläne für Objekte und/oder als Akteure dienen. Die Akteure (Objekt und Klassen) haben jeweils einen Zustand (abgelegt in Membervariablen). Sie können Botschaften empfangen und senden (heißt: eigene Methoden ausführen und die anderer Objekte/ Klassen aufrufen). BTW: Headerdateien und forward declarations sind bei C# absolut unüblich! S. Berninger DHBW Heidenheim Studiengang Informatik 7 Methoden: Parameter-Modifikatoren Methodensyntax: int Add (int a, int b) Zusätzlich: Parameter-Modifikatoren für Valuetypes, int Add (<mod> int a, <mod> int b) Übergabe der Referenz durch Laufzeitumgebung Alle Parameter-Modifikatoren müssen bei Definition und beim Aufruf angegeben werden! S. Berninger DHBW Heidenheim Studiengang Informatik 8 Methoden: Parameter-Modifikatoren Arten: • ref-Parameter: int Add (ref int a, ref int b) // a,b lesbar und schreibbar ermöglicht den Informationstransfer in beide Richtungen, Parameter muss vor Aufruf initialisiert sein.. • out-Parameter int Add (out int a, out int b) // a,b in Methode nur schreibbar aufgerufene Methode schreibt auf (verändert) Variable der rufenden Methode (Parameter muss vor Aufruf nicht initialisiert sein, reiner Returnwert) • in-Parameter int Add (in int a, in int b) // a,b trotz Referenz nur lesbar Übergabe einer Referenz, aber Verhinderung eines Schreibzugriffs. Parameter muss vor Aufruf initialisiert sein. • kein Modifikator (Kopie des ValueTypes wird übergeben, kein Schreibzugriff in Methode) S. Berninger DHBW Heidenheim Studiengang Informatik 9 ref-Parameter S. Berninger DHBW Heidenheim Studiengang Informatik 10 out-Parameter S. Berninger DHBW Heidenheim Studiengang Informatik 11 Programm liest für Aufrufer Werte von Konsole ein und übergibt diese in Out-Variable out-Parameter S. Berninger DHBW Heidenheim Studiengang Informatik 12 Aufrufname kann durch _ ersetzt werden, wenn man den Wert nicht abholen möchte (wird aber dennoch verändert!) in-Parameter S. Berninger DHBW Heidenheim Studiengang Informatik 13 Für Übergabe komplexer, großer Parameter ohne Wertkopie (größer als eine Speicheradresse). Variable muss initialisiert sein (wird gelesen), es findet keine automatische Typanpassung statt. Serien-Modifikator params [] S. Berninger DHBW Heidenheim Studiengang Informatik 14 Array-Parameter, der an letzter Stelle der Parameterliste stehen und in der Definition durch das Schlüsselwort params gekennzeichnet werden muss • erlaubt die Übergabe einer variablen Anzahl von Parametern gleichen Typs. • keine Angabe von params bei Aufruf! Modifikatoren von Methoden S. Berninger DHBW Heidenheim Studiengang Informatik 15 • async Durch den Modifikator async wird eine Methode als asynchron deklariert( -> Multithreading) • unsafe Markierung unsicheren Codes (z. B. unter Verwendung von Zeigeroperationen oder mit eingeschränkter Portierbarkeit) -> kein Bestandteil der Vorlesung Lokale Methoden S. Berninger DHBW Heidenheim Studiengang Informatik 16 Definition innerhalb einer ausführbaren Programmeinheit (z. B. Methode). Keine Ausnahme, sondern Normalfall! Sinn: lokal benötigte Hilfsmethoden, stärkere Modularisierung, mehrfacher Aufruf aus äußerer Methode (aber nur aus dieser) möglich Lokale Methoden S. Berninger DHBW Heidenheim Studiengang Informatik 17 LiesZwei() verwendet Lies(): class CProgram { void LiesZwei(out int z, out int n) { int Lies(string name) { Console.Write(name + \" = \"); return Convert.ToInt32(Console.ReadLine()); } z = Lies(\"Erstes Argument\"); n = Lies(\"Zweites Argument\"); } static void Main(string[] args) { CProgram p = new CProgram(); int x = 1, y = 2; p.LiesZwei(out x, out y); Console.WriteLine(\"\\nx % y = \" + (x%y)); } } Benannte Parameter (named arguments) S. Berninger DHBW Heidenheim Studiengang Informatik 18 Angabe des Parameternamens beim Aufruf vor dem Wert Vorteile: • Stellung der Parameter muss nicht bekannt sein und übereinstimmen • Lesbarkeit des Codes wird deutlich erhöht Beispiel: int Divide (int divisor, int dividend, out int remainder, bool setRem) b1.Divide(9, 3, rem, false); // Stellungsparameter lässt sich äquivalent auch so formulieren: b1.Divide(dividend: 3, divisor: 9, remainder: rem, setRem: false); // oder b1.Divide(9, 3, rem, setRem:false); // oder b1.Divide(divisor: 9, 3, rem, false); Optionale Parameter S. Berninger DHBW Heidenheim Studiengang Informatik 19 Formalparameter mit Voreinstellungswert, Angabe kann bei Aufruf weggelassen werden (von hinten) Regeln: Beispiel: public int Divide (int divisor, int dividend, out int remainder, bool setRem=false) { . . . } Aufruf z.B.: b1.Divide(9, 3, rem); • Als Voreinstellungswert ist ein konstanter Ausdruck erlaubt (Wert steht schon zur Übersetzungszeit fest: void Opt (int i = Int32.MaxValue - 1) { . . . } • Auf einen optionalen Formalparameter darf kein obligatorischer mehr folgen, nur weitere optionale. Default bei fehlender Angabe: private Explizit angebbar (möglichst erst nach allen private Membern): • public (Schnittstelle): Methode oder Attribut steht allen Klassen und Objekten zur Verfügung • private: Zugriff haben nur: Member dieser Klasse. • protected: Zugriff haben nur: Member dieser Klasse und alle von dieser Klasse abgeleiteten Klassen (auch in anderen Assemblies). Zugriffseinschränkungen durch Schutzklassen S. Berninger DHBW Heidenheim Studiengang Informatik 20 • private AND protected (protected --): Zugriff haben nur: Member dieser Klasse und alle von dieser Klasse abgeleiteten Klassen in derselben Assembly. Fortsetzung: • internal: Zugriff haben nur: Member aller Klassen der aktuellen Assembly (.exe oder .dll). Unit Tests nicht! Zugriffseinschränkungen durch Schutzklassen S. Berninger DHBW Heidenheim Studiengang Informatik 21 • protected OR internal (internal ++): Zugriff haben nur: Member dieser Klasse, alle Klassen innerhalb der gleichen Assembly und alle von dieser Klasse abgeleiteten Klassen anderer Assemblies (wie internal + abgeleitete Klassen in anderen Assemblies). Schutzklassen S. Berninger DHBW Heidenheim Studiengang Informatik 22 Signatur einer Methode S. Berninger DHBW Heidenheim Studiengang Informatik 23 <Return-Typ> Methodenname (<ParamTyp 1> , <ParamTyp2>, ... <ParamTyp n>) Signatur zur Signatur zählen nicht: - Typ des Returnwerts (Grund: wird vom Aufrufer häufig ignoriert – dann kann die Methode nicht ausgewählt werden)! - params-Modifier Methoden überladen (Overloading) S. Berninger DHBW Heidenheim Studiengang Informatik 24 Gleichnamige Methoden sind erlaubt, solange die Signatur unterschiedlich ist. Besitzt eine Klasse mehrere Methoden mit demselben Namen, liegt eine sogenannte Überladung von Methoden vor, wenn sich die Signaturen der beteiligten Methoden unterscheiden. Signaturen unterscheiden sich NICHT, wenn: • Die Namen der Methoden sind identisch und • Die Formalparameterlisten sind gleich lang und • Positionsgleiche Parameter stimmen hinsichtlich Datentyp und Parameterart (Wert-, ref-, in- bzw. out- Parameter) überein. eine Klasse, überladen mit gleichnamigen Methoden Nicht verwechseln mit: • Überschreiben (override, später): Methoden abgeleiteter Klassen haben bei gleicher Signatur unterschiedliche Implementierungen Methoden überladen S. Berninger DHBW Heidenheim Studiengang Informatik 25 Vorteile überladener Methoden mit unterschiedlichen Parametertypen: • Berechnung des Betrags einer Zahl in math.h, unterschiedlich codiert: public static float Abs(decimal value) public static double Abs(double value) public static long Abs(long value) Überladen von Methoden mit optionalen Parametern: • wenn eine Überladung mit einer kürzeren Parameterliste existiert, wobei mindestens ein optionaler Parameter fehlt, dann wird bei einem Aufruf mit der kürzeren Aktualparameterliste die Methode ohne optionale Parameter aufgerufen (kürzester Match gegen eine Deklaration). In dieser Konstellation ist die Definition von Voreinstellungswerten wirkungslos (s. nächste Folie). Methoden überladen S. Berninger DHBW Heidenheim Studiengang Informatik 26 Objekte S. Berninger DHBW Heidenheim Studiengang Informatik 27 Objekte CTruck truck; // truck: Referenzvariable, kann auf Objekte der Klasse CTruck und Objekte aller abgeleiteten // Klassen zeigen (noch ohne Wert), automatisch initialisiert auf null truck = new CTruck (seats=5, pricePerDay=35.70f, tankCapacity=75); // Anlegen eines Objekts durch Aufruf der // Konstruktormethode CTruck::CTruck(int, float, float) // Zuweisung der Referenz des Objekts an Referenz truck S. Berninger DHBW Heidenheim Studiengang Informatik 28 Referenzvariable cAdresse des Truckobjekts Truckobjekt color tankC. pricePerD. .„blue“ 75 35.70 seats 5 Objekte erzeugen - Konstruktoren Konstruktoren: spezielle Methoden für das Erzeugen/ Initialisieren neuer Objekte Aufgaben: • Instanzvariablen des Objekts initialisieren und/oder • andere Arbeiten verrichten (z. B. Öffnen einer Datei oder Netzwerkverbindung) Ziel: • ein neues Objekt in einen validen Zustand bringen und für seinen Einsatz vorbereiten Aufruf: • new-Operator, Konstruktormethode der gewünschten Klasse als Operand S. Berninger DHBW Heidenheim Studiengang Informatik 29 Objekte initialisieren – abgeleitete Klassen Schlüsselwort base: • Ruft einen Konstruktor der nächsthöheren Basisklasse (hier: CVehicle) auf: • Fehlt der explizite Aufruf: parameterloser Standardkonstruktor der Basisklasse wird aufgerufen -> hat die Basisklasse aber einen parameterbehafteten Konstruktor, muss sie den parameterlosen selbst definieren! S. Berninger DHBW Heidenheim Studiengang Informatik 30 public class CTruck: CVehicle { public CTruck (int seats, float payLoad , float pricePerDay): base (pricePerDay , seats) { Objekte initialisieren - Konstruktoren S. Berninger DHBW Heidenheim Studiengang Informatik 31 public class CTruck: CVehicle { public CTruck (int seats, float payLoad , float pricePerDay): base (pricePerDay , seats) { this.payLoad = payLoad; // ... oder: public class CTruck: CVehicle { public CTruck (int seats, float payLoad , float pricePerDay) // CVehicle braucht impliziten oder expliziten parameterlosen c`tor { this. seats = seats; // Member von CVehicle this. payLoad = payLoad; // Member von CTruck this. pricePerDay = pricePerDay; // Member von CVehicle // ... Objekte initialisieren - Konstruktoren Abarbeitungsreihenfolge (jeder Konstruktor ruft auf): - die null-Initialisierung der eigenen Instanzvariablen - explizite Feldinitialisierer der eigenen Klassen und der Basisklassen werden ausgeführt - dann • (implizit) den parameterlosen Standard-/Default-Konstruktor seiner unmittelbaren Basisklasse (inkl. null-Initialisierung der geerbten Member), der ruft wiederum zunächst den Konstruktor seiner Basisklasse .... u.s.w. • oder explizit über base einen parameterbehafteten Basisklassenkonstruktor (und s.o.) - Erst dann wird der Anweisungsteil des Konstruktors selbst ausgeführt. (Compilerfehler, wenn parameterloser Konstruktor in base fehlt, es aber einen mit Parametern gibt) S. Berninger DHBW Heidenheim Studiengang Informatik 32 Objekte initialisieren - Konstruktoren Syntax: • Methodenname entspricht Klassenname • kein Rückgabewert • Parameterliste möglich • Es sind beliebig viele überladene Konstruktoren mit demselben Namen und unterschiedlicher Parameterliste möglich • müssen (außer Standardkonstruktor) explizit public gesetzt werden, wenn gewünscht • Konstruktoren können i.d.R. nicht direkt aufgerufen, sondern nur als Argument des new-Operators verwendet werden S. Berninger DHBW Heidenheim Studiengang Informatik 33 Objekte initialisieren – Konstruktor-Arten Vorhandensein: a) es ist kein Konstruktor definiert (und nur dann): C# legt public Standard-Konstruktor (.ctor) ohne Parameter an, Aufruf: CRevenue rev = new CRevenue(); oder: var rev = new CRevenue(); b) mindestens ein Konstruktor mit Parameterliste ist definiert: -> parameterloser Konstruktor muss gegebenenfalls ebenfalls explizit definiert werden (Standard-Konstruktor wird nicht mehr automatisch angelegt) c) nur eigener parameterloser Konstruktor, z.B. public CRevenue() { amount=0.0;} S. Berninger DHBW Heidenheim Studiengang Informatik 34 Konstruktor: Form und Aufrufe Expression body: Der Konstruktor (oder beliebige andere Methode/ Property) enthält nur 1 Statement: -> ‚Expression body‘ ist möglich: public CRevenue () => amount = 0.0; // Lambda operator => Anderen eigenen Konstruktor aufrufen: • nur möglich über das Schlüsselwort this (statt base) zwischen Parameterliste und Implementierung: public CTruck (int seats, float tankCapacity , float pricePerDay) : this (int seats) {...} S. Berninger DHBW Heidenheim Studiengang Informatik 35 Weitere Konstruktoren a) Statischer Konstruktor: • Initialisiert statische Klassenvariable oder statische Klassen. • nicht-statischer Konstruktor ist bei statischen Klassen nicht erlaubt (auch kein Standardkonstruktor) • wird automatisch von Laufzeitumgebung aufgerufen b) privater Konstruktor: • verhindert das automatische Anlegen des public Standard-Konstruktors durch die Laufzeitumgebung, vor allem bei Klassen mit rein statischen Membern. Dort möchte man das Instanziieren ja vermeiden! • sind alle Member einer Klasse statisch: besser die ganze Klasse statisch machen, und dann siehe a) c) Zieltypisierter Aufruf (ab C# 9.0): • bei Konstruktoraufruf mit new kann die doppelte Nennung des Klassennamens vermieden werden: CRevenue rev = new CRevenue(); läßt sich vereinfachen zu: CRevenue rev = new(); oder: var rev = new CRevenue(); S. Berninger DHBW Heidenheim Studiengang Informatik 36 Objektinitialisierer Es muss kein parametrisierter Konstruktor benutzt werden, um Member zu initialisieren. ➔ Verwendung der Properties in einer Initialisierungsliste Dafür wird automatisch der parameterlose default-Konstruktor aufgerufen S. Berninger DHBW Heidenheim Studiengang Informatik 37 using System; class CRentACar { private CFleet fleet; private CRevenue revenue; public CRentACar () { fleet= new CFleet (); revenue= new CRevenue (500); // Anfangskapital, Konstruktor mit Parameter notwendig // alternativ: revenue= new (500); // Konstruktor mit Parameter notwendig // alternativ: revenue = new CRevenue {Amount=500}; // keine Konstruktordefinition notwendig, aber Setter // nicht möglich: revenue = new {Amount=500}; } } Abräumen von Objekten durch Garbage collection „Garbage collector“ = „Müllsammler“ Vorteile des vollautomatischen Garbage Collectors für Daten/ Objekte auf dem Heap: • vermeidet lästigen Aufwand • weil der Programmierer keine Verpflichtung (und Berechtigung) zum Entsorgen von Objekten hat, kann es nicht zu Programmabstürzen durch Zugriff auf voreilig vernichtete Objekte kommen. • es entstehen keine Speicherlöcher (engl.: memory leaks) durch versäumte Speicherfreigaben bei überflüssig gewordenen, nicht mehr erreichbaren Objekten S. Berninger DHBW Heidenheim Studiengang Informatik 38","libVersion":"0.3.2","langs":""}