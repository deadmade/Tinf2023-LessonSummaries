{"path":"DHBW Heidenheim/2024 SoSe/Theoretische Informatik/UnterrichtsMaterial/9. Woche Script Codeoptimierungen Theoretische Informatik II.pdf","text":"Studiengang Informatik Codeoptimierungen 1S. Berninger DHBW Heidenheim Studiengang Informatik Codeoptimierungen 2S. Berninger DHBW Heidenheim Voraussetzung für Codeoptimierung: 1) Aktuelles Big O für Laufzeit und Speicherbedarf bestimmen und: 2) Über das denkbar beste Big-O nachdenken! • Bsp.: Wir schreiben eine Funktion, die jedes Element eines Arrays ausgeben soll. Das denkbar beste Big O dafür ist: O(N)! Wenn wir nämlich jedes Element ausgeben sollen, haben wir keine andere Chance, als jedes Element zu besuchen… Für Optimierung also zwei Big O bestimmen: • das aktuelle • das denkbar beste -> Sind sie nicht gleich: Optimierungspotential! Nicht immer kann das denkbar beste Big O erreicht werden, aber vielleicht zumindest annähernd... Studiengang Informatik Denkbar bestes Big O 3S. Berninger DHBW Heidenheim Idee zu Erhöhung der Vorstellungskraft: “Würde ich jemandem glauben, der behauptet, mein Problem mit einem Big O von … gelöst zu haben?” Wenn ja, dann kann das mein denkbar bestes Big O sein... Studiengang Informatik Codeoptimierungen I: Schneller Lookup 4S. Berninger DHBW Heidenheim Fragen Sie sich: „Wenn ich durch Magie eine gewünschte Information in O(1) finden könnte, würde das meinen Algorithmus beschleunigen?“ Wenn ja: dann Hashtabelle benutzen, um die Magie wahr werden zu lassen. Bsp.: Zweier-Summen-Problem Eine Funktion soll „true“ zurückgeben, wenn in einem übergebenen Array mindestens 1 Zahlenpaar ist, das gemeinsam z.B. 10 ergibt. Der Einfachheit halber sind Duplikate ausgeschlossen (Array ist ein Set). Unser Array sei: [2, 0, 4, 1, 7, 9] Funktion gibt true zurück aufgrund 1 + 9! (false für [2, 0, 4, 5, 3, 9]). Erster Lösungs-Ansatz: Verschachtelte Schleifen Studiengang Informatik Codeoptimierungen I: Schneller Lookup 5S. Berninger DHBW Heidenheim Aktuelles Big O: O(N2) Denkbar bestes Big O: BigBlueButton: was wäre möglich? A O (1) B O (log N) C O (N) D O (N*logN) E O (N2) Studiengang Informatik Codeoptimierungen I: Schneller Lookup 6S. Berninger DHBW Heidenheim Magische Lookup-Frage: „Wenn ich durch Zauberhand eine gewünschte Information in O(1) finden könnte, würde das meinen Algorithmus beschleunigen?“ Wir laufen mit dieser Frage durch das Zweier-Summen-Problem: Für jede Zahl xi: ist die Zahl „yi=10-xi“ im Array enthalten? Könnten wir uns alle yi merken, könnten wir true zurückgeben, sobald wir auf eins davon stoßen – ansonsten false. Key 0 1 2 3 4 5 6 7 8 9 Value true true true false true false false true false true Index 0 1 2 3 4 5 6 7 8 9 -> wir brauchen eine extra Datenstruktur: eine Hashtabelle für magische Lookups . Unsere Hashtabelle könnte dann so aussehen: Studiengang Informatik Codeoptimierungen I: Schneller Lookup 7S. Berninger DHBW Heidenheim Key 0 1 2 3 4 5 6 7 8 9 Value true true true false true false false true false true Index 0 1 2 3 4 5 6 7 8 9 Für jede Zahl kann die Differenz zu 10 jetzt mit einem Lookup von O(1) nachgesehen werden: Resultierende Zeit-Performance: O(2N) = O(N)! Studiengang Informatik Codeoptimierungen II: Muster erkennen 8S. Berninger DHBW Heidenheim Muster im Problem finden: Komplexität rausnehmen! Münzenspiel: Zwei Spieler spielen im Wechsel, mit einem Stapel Münzen: Jeder Spieler kann genau eine oder genau zwei Münzen herunternehmen. Wer die letzte Münze nimmt, verliert. Mit der richtigen Strategie kann man den Gegner verlieren lassen (wenn man entscheiden darf, wer beginnt): • Bei einer letzten Münze verliert der Spieler, der an der Reihe ist. • Bei zwei oder drei Münzen kann der Spieler, der an der Reihe ist, den anderen verlieren lassen. • Vier Münzen: der Spieler an der Reihe wird verlieren. Studiengang Informatik Codeoptimierungen II: Muster erkennen 9S. Berninger DHBW Heidenheim Wie können wir mit einem Algorithmus vorhersagen, ob der Start-Spieler oder der Gegner bei einer bestimmten Münzenzahl das Spiel noch gewinnen können? Heißt auch: muss man bei einer bestimmten Münzenzahl selbst beginnen oder der Andere, um zu gewinnen? → Muster der Teilprobleme verwenden! Top-down-Rekursion! Studiengang Informatik Codeoptimierungen II: Muster erkennen 10S. Berninger DHBW Heidenheim Algorithmus optimierbar? Aktuelles Big O? A O (log N) B O (N) C O (N*logN) D O (N2) E O (2N) // currentplayer kann 1 oder 2 Münzen wegnehmen Studiengang Informatik Codeoptimierungen II: Muster erkennen 11S. Berninger DHBW Heidenheim Aktuelles Big O? BigBlueButton! A O (log N) B O (N) C O (N*logN) D O (N2) E O (2N) Studiengang Informatik Codeoptimierungen II: Muster erkennen 12S. Berninger DHBW Heidenheim Was ist das denkbar beste Big O? Müssen wir jede Münze des Stapels ansehen? Anzahl von Münzen Gewinner (it‘s your turn) 1 Them 2 You 3 You 4 Them 5 You 6 You 7 Them 8 You 9 You 10 ThemEs ist ein Muster erkennbar! Nein - uns interessiert nur seine Höhe! Sollte O(1) nicht möglich sein? Ist ein Muster erkennbar? Unterstützung zur Musterfindung: Wir erzeugen mehrere Beispiele aus Eingangs- und entsprechenden Ausgangsdaten. Studiengang Informatik Codeoptimierungen II: Muster erkennen 13S. Berninger DHBW Heidenheim Muster: Wenn wir von der Münzenzahl 1 abziehen, gewinnt der Gegner immer dann und nur dann, wenn die Zahl der Münzen durch 3 teilbar ist. Anzahl von Münzen Gewinner (it‘s your turn) 1 Them 2 You 3 You 4 Them 5 You 6 You 7 Them 8 You 9 You 10 Them O(1) bzgl. Laufzeit und Speicherplatz! Studiengang Informatik Codeoptimierungen II: Muster erkennen 14S. Berninger DHBW Heidenheim Das „Sum-Swap-Problem“ In diesem Beispiel können wir sowohl die Mustererkennung als auch das magische Lookup für die Optimierung verwenden: Unsere Funktion bekommt 2 Arrays von integer Werten, z.B. diese:. Wir suchen in jedem Array eine Zahl, die wir vertauschen können, damit die Summen gleich werden. BigBlueButton: array_1: A=5 B=3 C=2 D=9 E=1 array_2: A=1 B=12 C=5 Studiengang Informatik Codeoptimierungen II: Muster erkennen 15S. Berninger DHBW Heidenheim Wir vertauschen die 2 mit der 1: Unsere Funktion braucht den Swap nicht auszuführen – sie soll nur die beiden zu vertauschen Indizes zurückgeben, z.B. als Returnwert EXIT_SUCCESS und in einem Array (in unserem Beispiel [2, 0]) – oder EXIT_FAILURE im Returnwert, wenn es keine mögliche Vertauschung gibt. Wir könnten diese Funktion mit verschachtelten Schleifen schreiben – die äussere Schleife iteriert über Array 1 und die innere versucht, jeden Wert von array_1 mit jedem von array_2 auszutauschen. Aktuelle Komplexität: O (N*M) = O(N2) Denkbar bestes Big O: Wir müssen im worst case jede Zahl einmal besuchen. Das wäre O(N+M), also O(N). Studiengang Informatik Codeoptimierungen II: Muster erkennen 16S. Berninger DHBW Heidenheim Sind hier Muster verborgen? Beispiele rechnen: • Das Array mit der größeren Summe tauscht eine kleinere Zahl als der Array mit der kleineren Summe. • die Summen ändern sich um den gleichen Betrag • Die finale Summe liegt exakt in der Mitte der beiden Ausgangssummen. Studiengang Informatik Codeoptimierungen II: Muster erkennen 17S. Berninger DHBW Heidenheim 1. Wir können die finale Summe ermitteln. Wir suchen also für jede Zahl des einen Arrays nach einer ganz konkreter Zahl im anderen Array. Und hier können wir mit dem magischen Lookup beschleunigen. Wir speichern zunächst die Zahlen des einen Arrays in eine Hashtabelle, in der wir dann für jede Zahl der anderen Tabelle ihren Counterpart nachschlagen. 4. Wir suchen also für jede Zahl des Arrays nach folgendem Counterpart im anderen Array: Counterpart = Shift –+ Zahl 2. Daraus können wir bestimmen, um wieviel sich jede der Summen ändern muss (Shift). 3. Wir brauchen in jedem Array eine Zahl und einen Counterpart in dem anderen Array. Der Shift muss sich aus +-( Zahl-Counterpart) ergeben. Studiengang Informatik Codeoptimierungen II: Muster erkennen 18S. Berninger DHBW Heidenheim Studiengang Informatik Codeoptimierungen II: Muster erkennen 19S. Berninger DHBW Heidenheim Dieser Algorithmus läuft in (N+2*M)-Zeit! Wir benötigen Speicherplatz für eine extra Hashtabelle der Größe LIMIT – des maximalen Wertes, bzw. der Größe N, wenn wir aufgrund der Größe von LIMIT eine Hashfunktion einsetzen (Limit >> N) -> wir opfern Platz für Laufzeit. Studiengang Informatik Codeoptimierungen III: Datenstruktur wechseln 20S. Berninger DHBW Heidenheim Neues Gedankenspiel: Was passiert, wenn wir eine andere Datenstruktur verwenden? Bsp.: Wir arbeiten an einem Problem, bei dem uns die Daten als Array gegeben sind. Überlegung: würden uns Hash-Tabelle, Baum oder andere Struktur bei der Optimierung helfen? Studiengang Informatik Codeoptimierungen III: Datenstruktur wechseln 21S. Berninger DHBW Heidenheim Bsp. dazu: Anagramm checker: Sind 2 gegebene Strings Anagramme voneinander? Denkbar bestes Big O? Wir müssen jeden Buchstaben beider Strings bestimmt mindestens 1x besuchen (O(2N) = O(N)). Höhere Effizienz ist nicht vorstellbar. Möglicher Ansatz: Verschachtelte Schleifen, um die beiden Strings zu vergleichen. Die äußere Schleife iteriert über jedes Zeichen des ersten Strings, und vergleicht dieses mit jedem Zeichen des 2. Strings. Finden wir einen match, löschen wir das Zeichen aus dem 2. String. Wenn jedes Zeichen des 1. Strings auch im 2. String enthalten ist, darf der 2. String nach Ende der äußeren Schleife keine Zeichen mehr enthalten. Studiengang Informatik Codeoptimierungen III: Datenstruktur wechseln 22S. Berninger DHBW Heidenheim Implementierung: Studiengang Informatik Codeoptimierungen III: Datenstruktur wechseln 23S. Berninger DHBW Heidenheim Komplexität: O(N2) Schnellerer Ansatz: Beide Strings sortieren: müssen anschliessend identisch sein! -> O (2*N*logN + N) mit einem schnellen Sortieralgorithmus wie Quicksort. Wir möchten aber O (N)! Fragestellung: Sind in jeder Zeichenkette genausoviel Buchstaben des gleichen Typs? Alternative Datenstrukturen: Hashtabelle (Schritt 1 des Counting sort)? Zeichen als Key/ Index, speichert die Anzahl des Vorkommens im String? -> erfüllt genau unsere Fragestellung! Neue Fragestellung: sind die beiden resultierenden Hashtabellen identisch? Studiengang Informatik Codeoptimierungen III: Datenstruktur wechseln 24S. Berninger DHBW Heidenheim Studiengang Informatik Codeoptimierungen III: Datenstruktur wechseln 25S. Berninger DHBW Heidenheim Zeitkomplexität: O(N + N + 26) Speicherplatzkomplexität: O(2*26) = O(1) Studiengang Informatik Codeoptimierungen III: Datenstruktur wechseln 26S. Berninger DHBW Heidenheim Bsp. für andere Datenstruktur: Wir haben ein Array mit mehreren verschiedenen Werten, die wir neu anordnen wollen, so dass gleiche Werte zusammengruppiert werden. Die Reihenfolge der Gruppen interessiert uns allerdings nicht. Wir haben z.B. das Array: [\"a\", \"c\", \"d\", \"b\", \"b\", \"c\", \"a\", \"d\", \"c\", \"b\", \"a\", \"d\"] Die Gruppenbildung könnte z.B. ergeben: [\"c\", \"c\", \"c\", \"a\", \"a\", \"a\", \"d\", \"d\", \"d\", \"b\", \"b\", \"b\"] Ebenfalls gültige Ergebnisse wären: [\"d\", \"d\", \"d\", \"c\", \"c\", \"c\", \"a\", \"a\", \"a\", \"b\", \"b\", \"b\"] und [\"b\", \"b\", \"b\", \"c\", \"c\", \"c\", \"a\", \"a\", \"a\", \"d\", \"d\", \"d\"] Studiengang Informatik Codeoptimierungen III: Datenstruktur wechseln 27S. Berninger DHBW Heidenheim Jeder klassische Sortieralgorithmus würde mit O(N*logN) ergeben: [\"a\", \"a\", \"a\", \"b\", \"b\", \"b\", \"c\", \"c\", \"c\", \"d\", \"d\", \"d\"] Geht es schneller? Denkbar bestes Big O: O(N) vorstellbar, da nur die abzählbaren Häufigkeiten interessieren. Zählen in Hashtabelle + wieder rausschreiben (analog Counting sort). Wir erreichen O(N)-Zeit! Studiengang Informatik Codeoptimierungen III: Datenstruktur wechseln 28S. Berninger DHBW Heidenheim Studiengang Informatik Zusammenfassung 29S. Berninger DHBW Heidenheim Optimierung: 1. Aktuelles Big O bestimmen 2. Denkbar bestes Big O bestimmen 3. Algorithmus optimieren über • magisches Lookup, • Auffinden von Ergebnismustern, • andere Datenstrukturen … Diese Vorlesung sollte Ihnen ermöglichen, fundierte Entscheidungen bzgl. der Effizienz von Algorithmen zu treffen. Und: Themen wie diese, die als komplex und esoterisch verschrieen sind, basieren auf einfachen Konzepten. Lassen Sie sich nicht einschüchtern , wenn etwas zunächst komplex und schwierig aussieht – mit Hilfe von Beispielen kann alles einfach erklärt werden.","libVersion":"0.3.2","langs":""}